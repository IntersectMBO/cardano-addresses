-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library utilities for mnemonic generation and address derivation.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/IntersectMBO/cardano-addresses</a>
@package cardano-addresses
@version 3.12.0


-- | A compatibility function for the GHCJS build.
module Cardano.Address.Compat

-- | This function must be used somewhere, so that external Javascript
--   files are correctly linked in the GHCJS build.
--   
--   For non-GHCJS, it has no effect.
ghcjsBuildSupport :: IO ()


-- | Utility functions for internal use of the library.
module Cardano.Address.Internal
orElse :: Either e a -> Either e a -> Either e a
newtype WithErrorMessage e
WithErrorMessage :: e -> WithErrorMessage e
[withErrorMessage] :: WithErrorMessage e -> e
data DeserialiseFailure
DeserialiseFailure :: ByteOffset -> String -> DeserialiseFailure
instance (GHC.Exception.Type.Exception e, GHC.Generics.Generic e, Data.Aeson.Types.Class.GToJSON Data.Aeson.Types.Generic.Zero (GHC.Generics.Rep e)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Address.Internal.WithErrorMessage e)
instance Data.Aeson.Types.ToJSON.ToJSON Codec.CBOR.Read.DeserialiseFailure


-- | List common bech32 prefixes used for objects in the Cardano
--   eco-systems.
--   
--   As specified in <a>CIP-5</a>
module Cardano.Codec.Bech32.Prefixes
addr :: HumanReadablePart
addr_test :: HumanReadablePart
script :: HumanReadablePart
stake :: HumanReadablePart
stake_test :: HumanReadablePart
addr_vkh :: HumanReadablePart
stake_vkh :: HumanReadablePart
addr_shared_vkh :: HumanReadablePart
stake_shared_vkh :: HumanReadablePart
addr_vk :: HumanReadablePart
addr_sk :: HumanReadablePart
addr_xvk :: HumanReadablePart
addr_xsk :: HumanReadablePart
acct_vk :: HumanReadablePart
acct_sk :: HumanReadablePart
acct_xvk :: HumanReadablePart
acct_xsk :: HumanReadablePart
root_vk :: HumanReadablePart
root_sk :: HumanReadablePart
root_xvk :: HumanReadablePart
root_xsk :: HumanReadablePart
stake_vk :: HumanReadablePart
stake_sk :: HumanReadablePart
stake_xvk :: HumanReadablePart
stake_xsk :: HumanReadablePart
addr_shared_vk :: HumanReadablePart
addr_shared_sk :: HumanReadablePart
addr_shared_xvk :: HumanReadablePart
addr_shared_xsk :: HumanReadablePart
acct_shared_vk :: HumanReadablePart
acct_shared_sk :: HumanReadablePart
acct_shared_xvk :: HumanReadablePart
acct_shared_xsk :: HumanReadablePart
root_shared_vk :: HumanReadablePart
root_shared_sk :: HumanReadablePart
root_shared_xvk :: HumanReadablePart
root_shared_xsk :: HumanReadablePart
stake_shared_vk :: HumanReadablePart
stake_shared_sk :: HumanReadablePart
stake_shared_xvk :: HumanReadablePart
stake_shared_xsk :: HumanReadablePart
policy_vk :: HumanReadablePart
policy_xvk :: HumanReadablePart
policy_vkh :: HumanReadablePart
policy_xsk :: HumanReadablePart

module Cardano.Mnemonic

-- | Ease the manipulation of <a>Mnemonic</a> by encapsulating the type
--   constraints inside a constructor. This is particularly useful for
--   functions which do not require anything but a valid <a>Mnemonic</a>
--   without any particular pre-condition on the size of the
--   <a>Mnemonic</a> itself.
data SomeMnemonic
[SomeMnemonic] :: forall mw. KnownNat mw => Mnemonic mw -> SomeMnemonic

-- | This class enables caller to parse text list of variable length into
--   mnemonic sentences.
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
class MkSomeMnemonic (sz :: [Nat])

-- | Construct a mnemonic from a list of words. This function is
--   particularly useful when the number of words is not necessarily known
--   at runtime. The function is however <i>ambiguous</i> and requires
--   thereby a type application.
--   
--   <b>examples:</b>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 12 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Left "Invalid number of words: 12 words are expected."
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 9, 12, 15 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Right (SomeMnemonic ...)
--   </pre>
mkSomeMnemonic :: MkSomeMnemonic sz => [Text] -> Either (MkSomeMnemonicError sz) SomeMnemonic

-- | Error reported from trying to create a passphrase from a given
--   mnemonic
newtype MkSomeMnemonicError (sz :: [Nat])
MkSomeMnemonicError :: String -> MkSomeMnemonicError (sz :: [Nat])
[getMkSomeMnemonicError] :: MkSomeMnemonicError (sz :: [Nat]) -> String

-- | Convert a <a>SomeMnemonic</a> to bytes.
someMnemonicToBytes :: SomeMnemonic -> ScrubbedBytes

-- | Small helper to collect <a>Nat</a> values from a type-level list
class NatVals (ns :: [Nat])
natVals :: NatVals ns => Proxy ns -> [Integer]

-- | Smart-constructor for <a>Mnemonic</a>. Requires a type application to
--   disambiguate the mnemonic size.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkMnemonic @15 sentence
--   Mnemonic {} :: Mnemonic 15
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkMnemonic (mnemonicToText mnemonic) == Right mnemonic
--   </pre>
mkMnemonic :: forall (mw :: Nat) (ent :: Nat) csz. (ConsistentEntropy ent mw csz, EntropySize mw ~ ent) => [Text] -> Either (MkMnemonicError csz) (Mnemonic mw)

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MkMnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MkMnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MkMnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MkMnemonicError csz

-- | Convert a <a>Mnemonic</a> to a sentence of English mnemonic words.
mnemonicToText :: Mnemonic mw -> [Text]

-- | Convert a <a>Mnemonic</a> back to an <a>Entropy</a>.
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Generate Entropy of a given size using a cryptographically secure
--   random seed.
--   
--   <b>example:</b>
--   
--   <pre>
--   &gt;&gt;&gt; genEntropy @128
--   Entropy {} :: Entropy 128
--   </pre>
genEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => IO (Entropy ent)

-- | Smart-constructor for the <a>Entropy</a>. Make sure the
--   <tt>ByteString</tt> comes from a highly random source or use
--   <a>genEntropy</a>.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkEntropy @160 bytes
--   Entropy {} :: Entropy 160
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkEntropy (entropyToBytes ent) == Right ent
--   </pre>
mkEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => ScrubbedBytes -> Either (EntropyError csz) (Entropy ent)

-- | Convert <a>Entropy</a> to plain bytes.
entropyToBytes :: Entropy n -> ScrubbedBytes

-- | Convert an Entropy to a corresponding Mnemonic Sentence. Since
--   <a>Entropy</a> and <a>Mnemonic</a> can only be created through
--   smart-constructors, this function cannot fail and is total.
entropyToMnemonic :: forall mw ent csz. (ValidMnemonicSentence mw, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Entropy ent -> Mnemonic mw
instance GHC.Show.Show (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Mnemonic.Mnemonic mw)
instance Control.DeepSeq.NFData (Cardano.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Show.Show (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.Show.Show Cardano.Mnemonic.SomeMnemonic
instance (n GHC.Types.~ Crypto.Encoding.BIP39.EntropySize mw, csz GHC.Types.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz, Cardano.Mnemonic.MkSomeMnemonic rest, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.MkSomeMnemonic (mw : rest)
instance Cardano.Mnemonic.NatVals '[]
instance (GHC.TypeNats.KnownNat n, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.NatVals (n : rest)
instance (n GHC.Types.~ Crypto.Encoding.BIP39.EntropySize mw, csz GHC.Types.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz) => Cardano.Mnemonic.MkSomeMnemonic '[mw]
instance GHC.Classes.Eq Cardano.Mnemonic.SomeMnemonic
instance Control.DeepSeq.NFData Cardano.Mnemonic.SomeMnemonic
instance Control.DeepSeq.NFData (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Mnemonic.MnemonicException csz)
instance Control.DeepSeq.NFData (Cardano.Mnemonic.Mnemonic mw)
instance Control.DeepSeq.NFData (Crypto.Encoding.BIP39.EntropyError csz)
instance Control.DeepSeq.NFData Crypto.Encoding.BIP39.MnemonicWordsError
instance Control.DeepSeq.NFData Crypto.Encoding.BIP39.Dictionary.DictionaryError

module Cardano.Address.Derivation

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'PaymentK
--   </pre>
data Index (derivationType :: DerivationType) (depth :: Depth)

-- | Get the index as a <a>Word32</a> @since 3.3.0
indexToWord32 :: Index derivationType depth -> Word32

-- | Construct derivation path indices from raw <a>Word32</a> values.
indexFromWord32 :: forall ix derivationType depth. (ix ~ Index derivationType depth, Bounded ix) => Word32 -> Maybe ix

-- | Constructs a full domain <a>Index</a>. This can't fail, unlike
--   <tt>fromWord32</tt>.
wholeDomainIndex :: Word32 -> Index 'WholeDomain depth

-- | Upcasts an <a>Index</a> to one with the full <a>Word32</a> domain.
coerceWholeDomainIndex :: Index ty depth0 -> Index 'WholeDomain depth1

-- | Increment an index, if possible.
nextIndex :: forall ix derivationType depth. (ix ~ Index derivationType depth, Bounded ix) => ix -> Maybe ix

-- | Key Depth in the derivation path, according to BIP-0039 / BIP-0044
--   
--   <pre>
--   root | purpose' | cointype' | account' | role | address@
--   0th      1st         2nd        3rd       4th     5th
--   </pre>
--   
--   We do not manipulate purpose, cointype and change paths directly, so
--   there are no constructors for these.
data Depth
RootK :: Depth
AccountK :: Depth
PaymentK :: Depth
DelegationK :: Depth
ScriptK :: Depth
PolicyK :: Depth

-- | Type of derivation that should be used with the given indexes.
--   
--   In theory, we should only consider two derivation types: soft and
--   hard.
--   
--   However, historically, addresses in Cardano used to be generated
--   across both the soft and the hard domain. We therefore introduce a
--   <a>WholeDomain</a> derivation type that is the exact union of
--   <a>Hardened</a> and <a>Soft</a>.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType
WholeDomain :: DerivationType

-- | Abstract interface for constructing a <i>Master Key</i>.
class GenMasterKey (key :: Depth -> Type -> Type) where {
    type family SecondFactor key :: Type;
}

-- | Generate a root key from a corresponding mnemonic.
genMasterKeyFromMnemonic :: GenMasterKey key => SomeMnemonic -> SecondFactor key -> key 'RootK XPrv

-- | Generate a root key from a corresponding root <a>XPrv</a>
genMasterKeyFromXPrv :: GenMasterKey key => XPrv -> key 'RootK XPrv

-- | An interface for doing hard derivations from the root private key,
--   <i>Master Key</i>
class HardDerivation (key :: Depth -> Type -> Type) where {
    type family AccountIndexDerivationType key :: DerivationType;
    type family AddressIndexDerivationType key :: DerivationType;
    type family WithRole key :: Type;
}

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAccountPrivateKey :: HardDerivation key => key 'RootK XPrv -> Index (AccountIndexDerivationType key) 'AccountK -> key 'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAddressPrivateKey :: HardDerivation key => key 'AccountK XPrv -> WithRole key -> Index (AddressIndexDerivationType key) 'PaymentK -> key 'PaymentK XPrv

-- | An interface for doing soft derivations from an account public key
class HardDerivation key => SoftDerivation (key :: Depth -> Type -> Type)

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: SoftDerivation key => key 'AccountK XPub -> WithRole key -> Index 'Soft 'PaymentK -> key 'PaymentK XPub

-- | An opaque type representing an extended private key.
--   
--   <b>Properties:</b>
--   
--   <h5>Roundtripping</h5>
--   
--   <pre>
--   forall xprv. <a>xprvFromBytes</a> (<a>xprvToBytes</a> xprv) == <a>Just</a> xprv
--   </pre>
--   
--   <h5>Chain Code Invariance</h5>
--   
--   <pre>
--   forall xprv. <a>xprvChainCode</a> xprv == <a>xpubChainCode</a> (<a>toXPub</a> xprv)
--   </pre>
--   
--   <h5>Public Key Signature</h5>
--   
--   <pre>
--   forall xprv msg. <a>verify</a> (<a>toXPub</a> xprv) msg (<a>sign</a> xprv msg) == <a>True</a>
--   </pre>
type XPrv = XPrv

-- | Construct an <a>XPrv</a> from raw <a>ByteString</a> (96 bytes).
xprvFromBytes :: ByteString -> Maybe XPrv

-- | Convert an <a>XPrv</a> to a raw <a>ByteString</a> (96 bytes).
xprvToBytes :: XPrv -> ByteString

-- | Extract the private key from an <a>XPrv</a> as a raw <a>ByteString</a>
--   (64 bytes).
xprvPrivateKey :: XPrv -> ByteString

-- | Extract the chain code from an <a>XPrv</a> as a raw <a>ByteString</a>
--   (32 bytes).
xprvChainCode :: XPrv -> ByteString

-- | Derive the <a>XPub</a> associated with an <a>XPrv</a>.
toXPub :: HasCallStack => XPrv -> XPub

-- | An opaque type representing an extended public key.
--   
--   <b>Properties:</b>
--   
--   <h5>Roundtripping</h5>
--   
--   <pre>
--   forall xpub. <a>xpubFromBytes</a> (<a>xpubToBytes</a> xpub) == <a>Just</a> xpub
--   </pre>
type XPub = XPub

-- | Construct an <a>XPub</a> from raw <a>ByteString</a> (64 bytes).
xpubFromBytes :: ByteString -> Maybe XPub

-- | Convert an <a>XPub</a> to a raw <a>ByteString</a> (64 bytes).
xpubToBytes :: XPub -> ByteString

-- | Extract the public key from an <a>XPub</a> as a raw <a>ByteString</a>
--   (32 bytes).
xpubPublicKey :: XPub -> ByteString

-- | Extract the chain code from an <a>XPub</a> as a raw <a>ByteString</a>
--   (32 bytes).
xpubChainCode :: XPub -> ByteString

-- | An opaque type representing a non-extended public key.
--   
--   <b>Properties:</b>
--   
--   <h5>Roundtripping</h5>
--   
--   <pre>
--   forall pub. <a>pubFromBytes</a> (<a>pubToBytes</a> pub) == <a>Just</a> pub
--   </pre>
data Pub

-- | Construct a <a>Pub</a> from raw <a>ByteString</a> (32 bytes).
pubFromBytes :: ByteString -> Maybe Pub

-- | Convert an <a>Pub</a> to a raw <a>ByteString</a> (32 bytes).
pubToBytes :: Pub -> ByteString

-- | Extract the public key from an <a>XPub</a> as a <a>Pub</a> (32 bytes).
xpubToPub :: XPub -> Pub

-- | An opaque type representing a signature made from an <a>XPrv</a>.
type XSignature = XSignature

-- | Produce a signature of the given <tt>msg</tt> from an <a>XPrv</a>.
sign :: ByteArrayAccess msg => XPrv -> msg -> XSignature

-- | Verify the <a>XSignature</a> of a <tt>msg</tt> with the <a>XPub</a>
--   associated with the <a>XPrv</a> used for signing.
verify :: ByteArrayAccess msg => XPub -> msg -> XSignature -> Bool
instance GHC.Classes.Eq Cardano.Address.Derivation.Pub
instance GHC.Show.Show Cardano.Address.Derivation.Pub
instance GHC.Classes.Ord (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Classes.Eq (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Show.Show (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Generics.Generic (Cardano.Address.Derivation.Index derivationType depth)
instance Control.DeepSeq.NFData (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Hardened depth)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Soft depth)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.WholeDomain depth)
instance Formatting.Buildable.Buildable (Cardano.Address.Derivation.Index derivationType depth)

module Cardano.Address.Script

-- | A <a>Script</a> type represents multi signature script. The script
--   embodies conditions that need to be satisfied to make it valid.
data Script (elem :: Type)
RequireSignatureOf :: !elem -> Script (elem :: Type)
RequireAllOf :: ![Script elem] -> Script (elem :: Type)
RequireAnyOf :: ![Script elem] -> Script (elem :: Type)
RequireSomeOf :: Word8 -> ![Script elem] -> Script (elem :: Type)
ActiveFromSlot :: Natural -> Script (elem :: Type)
ActiveUntilSlot :: Natural -> Script (elem :: Type)

-- | This function realizes what cardano-node's `Api.serialiseToCBOR
--   script` realizes This is basically doing the symbolically following:
--   toCBOR [0,multisigScript]
serializeScript :: Script KeyHash -> ByteString

-- | <a>Script</a> folding
foldScript :: (a -> b -> b) -> b -> Script a -> b

-- | Represents the script template that show the structure of the script
--   and determines the expected place of verification keys corresponding
--   to given cosigners.
data ScriptTemplate
ScriptTemplate :: Map Cosigner XPub -> Script Cosigner -> ScriptTemplate
[cosigners] :: ScriptTemplate -> Map Cosigner XPub
[template] :: ScriptTemplate -> Script Cosigner

-- | Represents the cosigner of the script, ie., party that co-shares the
--   script.
newtype Cosigner
Cosigner :: Word8 -> Cosigner

-- | Possible validation errors when validating a script
data ErrValidateScript
LedgerIncompatible :: ErrValidateScript
WrongKeyHash :: ErrValidateScript
NotUniformKeyType :: ErrValidateScript
Malformed :: ErrValidateScript
NotRecommended :: ErrRecommendedValidateScript -> ErrValidateScript

-- | Possible recommended validation errors when validating a script
data ErrRecommendedValidateScript
EmptyList :: ErrRecommendedValidateScript
ListTooSmall :: ErrRecommendedValidateScript
MZero :: ErrRecommendedValidateScript
DuplicateSignatures :: ErrRecommendedValidateScript
RedundantTimelocks :: ErrRecommendedValidateScript
TimelockTrap :: ErrRecommendedValidateScript

-- | Possible validation errors when validating a script template
data ErrValidateScriptTemplate
WrongScript :: ErrValidateScript -> ErrValidateScriptTemplate
DuplicateXPubs :: ErrValidateScriptTemplate
UnknownCosigner :: ErrValidateScriptTemplate
MissingCosignerXPub :: ErrValidateScriptTemplate
NoCosignerInScript :: ErrValidateScriptTemplate
NoCosignerXPub :: ErrValidateScriptTemplate

-- | Validate a <a>Script</a>, semantically
validateScript :: ValidationLevel -> Script KeyHash -> Either ErrValidateScript ()

-- | Validate a <a>ScriptTemplate</a>, semantically
validateScriptTemplate :: ValidationLevel -> ScriptTemplate -> Either ErrValidateScriptTemplate ()

-- | Validate a script in <a>ScriptTemplate</a>
validateScriptOfTemplate :: ValidationLevel -> Script Cosigner -> Either ErrValidateScript ()

-- | Pretty-print a script validation error.
prettyErrValidateScript :: ErrValidateScript -> String

-- | Pretty-print a script template validation error.
prettyErrValidateScriptTemplate :: ErrValidateScriptTemplate -> String

-- | A <a>ScriptHash</a> type represents script hash. The hash is expected
--   to have size of 28-byte.
newtype ScriptHash
ScriptHash :: ByteString -> ScriptHash
[unScriptHash] :: ScriptHash -> ByteString

-- | Computes the hash of a given script, by first serializing it to CBOR.
toScriptHash :: Script KeyHash -> ScriptHash

-- | Construct an <a>ScriptHash</a> from raw <a>ByteString</a> (28 bytes).
scriptHashFromBytes :: ByteString -> Maybe ScriptHash

-- | A <a>KeyHash</a> type represents verification key hash that
--   participate in building multi-signature script. The hash is expected
--   to have size of 28-byte.
data KeyHash
KeyHash :: KeyRole -> ByteString -> KeyHash
[role] :: KeyHash -> KeyRole
[digest] :: KeyHash -> ByteString

-- | Construct an <a>KeyHash</a> from raw <a>ByteString</a> (28 bytes).
keyHashFromBytes :: (KeyRole, ByteString) -> Maybe KeyHash

-- | Construct a <a>KeyHash</a> from <a>Text</a>. It should be Bech32
--   encoded text with one of following hrp: - <tt>addr_shared_vkh</tt> -
--   <tt>stake_shared_vkh</tt> - <tt>addr_vkh</tt> - <tt>stake_vkh</tt> -
--   <tt>policy_vkh</tt> - <tt>addr_shared_vk</tt> -
--   <tt>stake_shared_vk</tt> - <tt>addr_vk</tt> - <tt>stake_vk</tt> -
--   <tt>addr_shared_xvk</tt> - <tt>stake_shared_xvk</tt> -
--   <tt>addr_xvk</tt> - <tt>stake_xvk</tt> - <tt>policy_vk</tt> -
--   <tt>policy_xvk</tt> Raw keys will be hashed on the fly, whereas hash
--   that are directly provided will remain as such. If if hex is
--   encountered Unknown policy key is assumed
keyHashFromText :: Text -> Either ErrKeyHashFromText KeyHash

-- | Encode a <a>KeyHash</a> to bech32 <a>Text</a> or hex is key role
--   unknown.
keyHashToText :: KeyHash -> Text
instance GHC.Classes.Eq elem => GHC.Classes.Eq (Cardano.Address.Script.Script elem)
instance GHC.Show.Show elem => GHC.Show.Show (Cardano.Address.Script.Script elem)
instance GHC.Generics.Generic (Cardano.Address.Script.Script elem)
instance GHC.Classes.Eq Cardano.Address.Script.Cosigner
instance GHC.Classes.Ord Cardano.Address.Script.Cosigner
instance GHC.Generics.Generic Cardano.Address.Script.Cosigner
instance GHC.Classes.Eq Cardano.Address.Script.ScriptTemplate
instance GHC.Show.Show Cardano.Address.Script.ScriptTemplate
instance GHC.Generics.Generic Cardano.Address.Script.ScriptTemplate
instance GHC.Classes.Eq Cardano.Address.Script.ScriptHash
instance GHC.Classes.Ord Cardano.Address.Script.ScriptHash
instance GHC.Show.Show Cardano.Address.Script.ScriptHash
instance GHC.Generics.Generic Cardano.Address.Script.ScriptHash
instance GHC.Classes.Eq Cardano.Address.Script.KeyRole
instance GHC.Classes.Ord Cardano.Address.Script.KeyRole
instance GHC.Show.Show Cardano.Address.Script.KeyRole
instance GHC.Generics.Generic Cardano.Address.Script.KeyRole
instance GHC.Classes.Eq Cardano.Address.Script.KeyHash
instance GHC.Classes.Ord Cardano.Address.Script.KeyHash
instance GHC.Show.Show Cardano.Address.Script.KeyHash
instance GHC.Generics.Generic Cardano.Address.Script.KeyHash
instance GHC.Generics.Generic Cardano.Address.Script.ValidationLevel
instance GHC.Classes.Eq Cardano.Address.Script.ValidationLevel
instance GHC.Show.Show Cardano.Address.Script.ValidationLevel
instance GHC.Classes.Eq Cardano.Address.Script.ErrKeyHashFromText
instance GHC.Show.Show Cardano.Address.Script.ErrKeyHashFromText
instance GHC.Show.Show Cardano.Address.Script.ErrRecommendedValidateScript
instance GHC.Classes.Eq Cardano.Address.Script.ErrRecommendedValidateScript
instance GHC.Show.Show Cardano.Address.Script.ErrValidateScript
instance GHC.Classes.Eq Cardano.Address.Script.ErrValidateScript
instance GHC.Show.Show Cardano.Address.Script.ErrValidateScriptTemplate
instance GHC.Classes.Eq Cardano.Address.Script.ErrValidateScriptTemplate
instance Control.DeepSeq.NFData Cardano.Address.Script.ValidationLevel
instance Control.DeepSeq.NFData Cardano.Address.Script.KeyHash
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Script.KeyHash
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Address.Script.Script Cardano.Address.Script.KeyHash)
instance Control.DeepSeq.NFData Cardano.Address.Script.KeyRole
instance Control.DeepSeq.NFData Cardano.Address.Script.ScriptHash
instance Control.DeepSeq.NFData Cardano.Address.Script.ScriptTemplate
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Script.ScriptTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Address.Script.ScriptTemplate
instance Data.Hashable.Class.Hashable Cardano.Address.Script.Cosigner
instance Control.DeepSeq.NFData Cardano.Address.Script.Cosigner
instance GHC.Show.Show Cardano.Address.Script.Cosigner
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Script.Cosigner
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Address.Script.Cosigner
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Address.Script.Script Cardano.Address.Script.Cosigner)
instance Control.DeepSeq.NFData elem => Control.DeepSeq.NFData (Cardano.Address.Script.Script elem)
instance Data.Aeson.Types.ToJSON.ToJSON elem => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Address.Script.Script elem)

module Cardano.Address.Script.Parser

-- | Run <a>scriptParser</a> on string input.
scriptFromString :: ReadP (Script a) -> String -> Either ErrValidateScript (Script a)

-- | Defines canonical string output for script that is consistent with
--   <a>scriptFromString</a>.
scriptToText :: Show a => Script a -> Text

-- | The script embodies combination of signing keys that need to be met to
--   make it valid. We assume here that the script could delivered from
--   standard input. The examples below are self-explanatory:
--   
--   <ol>
--   <li>requiring signature
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe</li>
--   <li><a>any</a> for signature required any
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe,
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1]</li>
--   <li><a>all</a> signatures required all
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe,
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1]</li>
--   <li><tt>at_least</tt> 1 signature required at_least 1
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe,
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1]</li>
--   <li>Nested script are supported at_least 1
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe, all
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1,
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1]]</li>
--   <li>1 signature required after slot number 120 all
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe, active_from
--   120]</li>
--   <li>1 signature required until slot number 150 all
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe,
--   active_until 150]</li>
--   <li>1 signature required in slot interval &lt;145, 150) all
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe, active_from
--   145, active_until 150]</li>
--   </ol>
--   
--   Parser is insensitive to whitespaces.
scriptParser :: ReadP (Script a) -> ReadP (Script a)

module Cardano.Address

-- | An <a>Address</a> type representing <tt>Cardano</tt> addresses.
--   Internals are irrevelant to the user.
data Address

-- | Encoding of addresses for certain key types and backend targets.
class HasNetworkDiscriminant key => PaymentAddress key

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
paymentAddress :: PaymentAddress key => NetworkDiscriminant key -> key 'PaymentK XPub -> Address

-- | Encoding of addresses for certain key types and backend targets.
class HasNetworkDiscriminant key => StakeAddress key

-- | Convert a delegation key to a stake <a>Address</a> (aka: reward
--   account address) valid for the given network discrimination.
stakeAddress :: StakeAddress key => NetworkDiscriminant key -> key 'DelegationK XPub -> Address

-- | Encoding of delegation addresses for certain key types and backend
--   targets.
class PaymentAddress key => DelegationAddress key

-- | Convert a public key and a delegation key to a delegation
--   <a>Address</a> valid for the given network discrimination. Funds sent
--   to this address will be delegated according to the delegation settings
--   attached to the delegation key.
delegationAddress :: DelegationAddress key => NetworkDiscriminant key -> key 'PaymentK XPub -> key 'DelegationK XPub -> Address

-- | Encoding of pointer addresses for payment key type, pointer to
--   delegation certificate in the blockchain and backend targets.
class PaymentAddress key => PointerAddress key

-- | Convert a payment public key and a pointer to delegation key in the
--   blockchain to a delegation <a>Address</a> valid for the given network
--   discrimination. Funds sent to this address will be delegated according
--   to the delegation settings attached to the delegation key located by
--   <a>ChainPointer</a>.
pointerAddress :: PointerAddress key => NetworkDiscriminant key -> key 'PaymentK XPub -> ChainPointer -> Address

-- | A <a>ChainPointer</a> type representing location of some object in the
--   blockchain (eg., delegation certificate). This can be achieved
--   unambiguously by specifying slot number, transaction index and the
--   index in the object list (eg., certification list). For delegation
--   certificates, alternatively, the delegation key can be used and then
--   <a>DelegationAddress</a> can be used.
data ChainPointer
ChainPointer :: Natural -> Natural -> Natural -> ChainPointer

-- | Pointer to the slot
[slotNum] :: ChainPointer -> Natural

-- | transaction index
[transactionIndex] :: ChainPointer -> Natural

-- | output list index
[outputIndex] :: ChainPointer -> Natural

-- | Encode an <a>Address</a> to a base58 <a>Text</a>.
base58 :: Address -> Text

-- | Decode a base58-encoded <a>Text</a> into an <a>Address</a>
fromBase58 :: Text -> Maybe Address

-- | Encode a Shelley <a>Address</a> to bech32 <a>Text</a>, using
--   <tt>addr</tt> or <tt>addr_test</tt> as a human readable prefix
--   (depending on the network tag in the address).
bech32 :: Address -> Text

-- | Encode an <a>Address</a> to bech32 <a>Text</a>, using the specified
--   human readable prefix.
bech32With :: HumanReadablePart -> Address -> Text

-- | Decode a bech32-encoded <a>Text</a> into an <a>Address</a>
fromBech32 :: Text -> Maybe Address
instance GHC.Classes.Ord Cardano.Address.Address
instance GHC.Classes.Eq Cardano.Address.Address
instance GHC.Show.Show Cardano.Address.Address
instance GHC.Generics.Generic Cardano.Address.Address
instance GHC.Classes.Ord Cardano.Address.ChainPointer
instance GHC.Classes.Eq Cardano.Address.ChainPointer
instance GHC.Show.Show Cardano.Address.ChainPointer
instance GHC.Generics.Generic Cardano.Address.ChainPointer
instance GHC.Classes.Eq Cardano.Address.NetworkTag
instance GHC.Show.Show Cardano.Address.NetworkTag
instance GHC.Generics.Generic Cardano.Address.NetworkTag
instance GHC.Classes.Eq Cardano.Address.AddressDiscrimination
instance GHC.Show.Show Cardano.Address.AddressDiscrimination
instance GHC.Generics.Generic Cardano.Address.AddressDiscrimination
instance Control.DeepSeq.NFData Cardano.Address.AddressDiscrimination
instance Control.DeepSeq.NFData Cardano.Address.NetworkTag
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.NetworkTag
instance Control.DeepSeq.NFData Cardano.Address.ChainPointer
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.ChainPointer
instance Control.DeepSeq.NFData Cardano.Address.Address


module Cardano.Address.Style.Byron

-- | Material for deriving HD random scheme keys, which can be used for
--   making addresses.

-- | <i>Deprecated: see <a>Icarus</a></i>
data Byron (depth :: Depth) key

-- | The hierarchical derivation indices for a given level/depth.

-- | <i>Deprecated: see <a>Icarus</a></i>
type family DerivationPath (depth :: Depth) :: Type

-- | Used for encryption of the derivation path payload within an address.

-- | <i>Deprecated: see <a>Icarus</a></i>
($sel:payloadPassphrase:Byron) :: Byron depth key -> ScrubbedBytes

-- | The address derivation indices for the level of this key.

-- | <i>Deprecated: see <a>Icarus</a></i>
($sel:derivationPath:Byron) :: Byron depth key -> DerivationPath depth

-- | The raw private or public key.

-- | <i>Deprecated: see <a>Icarus</a></i>
($sel:getKey:Byron) :: Byron depth key -> key

-- | Generate a root key from a corresponding root <a>XPrv</a>

-- | <i>Deprecated: see <a>Icarus</a></i>
genMasterKeyFromXPrv :: XPrv -> Byron 'RootK XPrv

-- | Generate a root key from a corresponding mnemonic.

-- | <i>Deprecated: see <a>Icarus</a></i>
genMasterKeyFromMnemonic :: SomeMnemonic -> Byron 'RootK XPrv

-- | Derives an account private key from the given root private key.

-- | <i>Deprecated: see <a>Icarus</a></i>
deriveAccountPrivateKey :: Byron 'RootK XPrv -> Index 'WholeDomain 'AccountK -> Byron 'AccountK XPrv

-- | Derives an address private key from the given account private key.

-- | <i>Deprecated: see <a>Icarus</a></i>
deriveAddressPrivateKey :: Byron 'AccountK XPrv -> Index 'WholeDomain 'PaymentK -> Byron 'PaymentK XPrv

-- | The result of <a>eitherInspectAddress</a> for Byron addresses.
data AddressInfo
AddressInfo :: !ByteString -> !PayloadInfo -> !Maybe NetworkTag -> AddressInfo
[$sel:infoAddressRoot:AddressInfo] :: AddressInfo -> !ByteString
[$sel:infoPayload:AddressInfo] :: AddressInfo -> !PayloadInfo
[$sel:infoNetworkTag:AddressInfo] :: AddressInfo -> !Maybe NetworkTag

-- | Determines whether an <a>Address</a> is a Byron address.
--   
--   Returns either details about the <a>Address</a>, or
--   <a>ErrInspectAddress</a> if it's not a valid address.
eitherInspectAddress :: Maybe XPub -> Address -> Either ErrInspectAddress AddressInfo

-- | Determines whether an <a>Address</a> is a Byron address.
--   
--   Returns a JSON object with information about the address, or throws
--   <a>ErrInspectAddress</a> if the address isn't a byron address.
inspectAddress :: forall m. MonadThrow m => Maybe XPub -> Address -> m Value

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
paymentAddress :: NetworkDiscriminant Byron -> Byron 'PaymentK XPub -> Address

-- | Pretty-print an <a>ErrInspectAddress</a>
prettyErrInspectAddress :: ErrInspectAddress -> String

-- | <a>NetworkDiscriminant</a> for Cardano MainNet &amp; Byron
byronMainnet :: NetworkDiscriminant Byron

-- | <a>NetworkDiscriminant</a> for Cardano Staging &amp; Byron
byronStaging :: NetworkDiscriminant Byron

-- | <a>NetworkDiscriminant</a> for Cardano Testnet &amp; Byron
byronTestnet :: NetworkDiscriminant Byron

-- | <a>NetworkDiscriminant</a> for Cardano Preprod &amp; Byron
byronPreprod :: NetworkDiscriminant Byron

-- | <a>NetworkDiscriminant</a> for Cardano Preview &amp; Byron
byronPreview :: NetworkDiscriminant Byron

-- | Backdoor for generating a new key from a raw <a>XPrv</a>.
--   
--   Note that the <tt>depth</tt> is left open so that the caller gets to
--   decide what type of key this is. This is mostly for testing, in
--   practice, seeds are used to represent root keys, and one should
--   <a>genMasterKeyFromXPrv</a>
--   
--   The first argument is a type-family <a>DerivationPath</a> and its type
--   depends on the <tt>depth</tt> of the key.
--   
--   <b>examples:</b>
--   
--   <pre>
--   &gt;&gt;&gt; liftXPrv rootPrv () prv
--   _ :: Byron RootK XPrv
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftXPrv rootPrv minBound prv
--   _ :: Byron AccountK XPrv
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftXPrv rootPrv (minBound, minBound) prv
--   _ :: Byron PaymentK XPrv
--   </pre>

-- | <i>Deprecated: see <a>Icarus</a></i>
liftXPrv :: XPub -> DerivationPath depth -> XPrv -> Byron depth XPrv

-- | Backdoor for generating a new key from a raw <a>XPub</a>.
--   
--   Note that the <tt>depth</tt> is left open so that the caller gets to
--   decide what type of key this is. This is mostly for testing, in
--   practice, seeds are used to represent root keys, and one should
--   <a>genMasterKeyFromXPrv</a>
--   
--   see also <a>liftXPrv</a>

-- | <i>Deprecated: see <a>Icarus</a></i>
liftXPub :: XPub -> DerivationPath depth -> XPub -> Byron depth XPub
instance GHC.Generics.Generic (Cardano.Address.Style.Byron.Byron depth key)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Style.Byron.ErrInspectAddress
instance GHC.Classes.Eq Cardano.Address.Style.Byron.ErrInspectAddress
instance GHC.Show.Show Cardano.Address.Style.Byron.ErrInspectAddress
instance GHC.Generics.Generic Cardano.Address.Style.Byron.ErrInspectAddress
instance GHC.Classes.Eq Cardano.Address.Style.Byron.PayloadInfo
instance GHC.Show.Show Cardano.Address.Style.Byron.PayloadInfo
instance GHC.Generics.Generic Cardano.Address.Style.Byron.PayloadInfo
instance GHC.Classes.Eq Cardano.Address.Style.Byron.AddressInfo
instance GHC.Show.Show Cardano.Address.Style.Byron.AddressInfo
instance GHC.Generics.Generic Cardano.Address.Style.Byron.AddressInfo
instance (GHC.Show.Show key, GHC.Show.Show (Cardano.Address.Style.Byron.DerivationPath depth)) => GHC.Show.Show (Cardano.Address.Style.Byron.Byron depth key)
instance (GHC.Classes.Eq key, GHC.Classes.Eq (Cardano.Address.Style.Byron.DerivationPath depth)) => GHC.Classes.Eq (Cardano.Address.Style.Byron.Byron depth key)
instance GHC.Base.Functor (Cardano.Address.Style.Byron.Byron depth)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Style.Byron.AddressInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Style.Byron.PayloadInfo
instance GHC.Exception.Type.Exception Cardano.Address.Style.Byron.ErrInspectAddress
instance (Control.DeepSeq.NFData key, Control.DeepSeq.NFData (Cardano.Address.Style.Byron.DerivationPath depth)) => Control.DeepSeq.NFData (Cardano.Address.Style.Byron.Byron depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Byron.Byron
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Byron.Byron
instance Cardano.Address.PaymentAddress Cardano.Address.Style.Byron.Byron
instance Cardano.Address.HasNetworkDiscriminant Cardano.Address.Style.Byron.Byron


module Cardano.Address.Style.Icarus

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Icarus 'RootK XPrv
--   let accountPubKey  = Icarus 'AccountK XPub
--   let addressPubKey  = Icarus 'PaymentK XPub
--   </pre>
data Icarus (depth :: Depth) key

-- | Extract the raw <a>XPrv</a> or <a>XPub</a> wrapped by this type.
getKey :: Icarus depth key -> key

-- | Generate a root key from a corresponding root <a>XPrv</a>
genMasterKeyFromXPrv :: XPrv -> Icarus 'RootK XPrv

-- | Generate a root key from a corresponding mnemonic.
genMasterKeyFromMnemonic :: SomeMnemonic -> ScrubbedBytes -> Icarus 'RootK XPrv

-- | Derives an account private key from the given root private key.
deriveAccountPrivateKey :: Icarus 'RootK XPrv -> Index 'Hardened 'AccountK -> Icarus 'AccountK XPrv

-- | Derives an address private key from the given account private key.
deriveAddressPrivateKey :: Icarus 'AccountK XPrv -> Role -> Index 'Soft 'PaymentK -> Icarus 'PaymentK XPrv

-- | Derives an address public key from the given account public key.
deriveAddressPublicKey :: Icarus 'AccountK XPub -> Role -> Index 'Soft 'PaymentK -> Icarus 'PaymentK XPub

-- | The result of <a>eitherInspectAddress</a> for Icarus addresses.
data AddressInfo
AddressInfo :: !ByteString -> !Maybe NetworkTag -> AddressInfo
[infoAddressRoot] :: AddressInfo -> !ByteString
[infoNetworkTag] :: AddressInfo -> !Maybe NetworkTag

-- | Determines whether an <a>Address</a> is an Icarus address.
--   
--   Returns either details about the <a>Address</a>, or
--   <a>ErrInspectAddress</a> if it's not a valid icarus address.
eitherInspectAddress :: Address -> Either ErrInspectAddress AddressInfo

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
paymentAddress :: NetworkDiscriminant Icarus -> Icarus 'PaymentK XPub -> Address

-- | Pretty-print an <a>ErrInspectAddress</a>
prettyErrInspectAddress :: ErrInspectAddress -> String

-- | <a>NetworkDiscriminant</a> for Cardano MainNet &amp; <a>Icarus</a>
icarusMainnet :: NetworkDiscriminant Icarus

-- | <a>NetworkDiscriminant</a> for Cardano Staging &amp; <a>Icarus</a>
icarusStaging :: NetworkDiscriminant Icarus

-- | <a>NetworkDiscriminant</a> for Cardano Testnet &amp; <a>Icarus</a>
icarusTestnet :: NetworkDiscriminant Icarus

-- | <a>NetworkDiscriminant</a> for Cardano Preview &amp; <a>Icarus</a>
icarusPreview :: NetworkDiscriminant Icarus

-- | <a>NetworkDiscriminant</a> for Cardano Preprod &amp; <a>Icarus</a>
icarusPreprod :: NetworkDiscriminant Icarus

-- | Unsafe backdoor for constructing an <a>Icarus</a> key from a raw
--   <a>XPrv</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPrv :: XPrv -> Icarus depth XPrv

-- | Unsafe backdoor for constructing an <a>Icarus</a> key from a raw
--   <a>XPub</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPub :: XPub -> Icarus depth XPub
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Generics.Generic (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Enum.Bounded Cardano.Address.Style.Icarus.Role
instance GHC.Classes.Ord Cardano.Address.Style.Icarus.Role
instance GHC.Classes.Eq Cardano.Address.Style.Icarus.Role
instance GHC.Show.Show Cardano.Address.Style.Icarus.Role
instance GHC.Generics.Generic Cardano.Address.Style.Icarus.Role
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Style.Icarus.ErrInspectAddress
instance GHC.Classes.Eq Cardano.Address.Style.Icarus.ErrInspectAddress
instance GHC.Show.Show Cardano.Address.Style.Icarus.ErrInspectAddress
instance GHC.Generics.Generic Cardano.Address.Style.Icarus.ErrInspectAddress
instance GHC.Classes.Eq Cardano.Address.Style.Icarus.AddressInfo
instance GHC.Show.Show Cardano.Address.Style.Icarus.AddressInfo
instance GHC.Generics.Generic Cardano.Address.Style.Icarus.AddressInfo
instance GHC.Base.Functor (Cardano.Address.Style.Icarus.Icarus depth)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Style.Icarus.AddressInfo
instance GHC.Exception.Type.Exception Cardano.Address.Style.Icarus.ErrInspectAddress
instance Control.DeepSeq.NFData Cardano.Address.Style.Icarus.Role
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Icarus.Icarus
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Address.Style.Icarus.Icarus depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.Derivation.SoftDerivation Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.PaymentAddress Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.HasNetworkDiscriminant Cardano.Address.Style.Icarus.Icarus


module Data.Word7

-- | A <a>Word7</a> algebraic data-type. @since 2.0.0
data Word7
toWord7 :: Word8 -> Word7
toWord8 :: Word7 -> Word8
toWord7s :: Natural -> [Word7]
toNatural :: [Word7] -> Natural
putVariableLengthNat :: Natural -> Put
getVariableLengthNat :: Get Natural
instance GHC.Show.Show Data.Word7.Word7
instance GHC.Classes.Eq Data.Word7.Word7


module Cardano.Address.Style.Shelley

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Shelley 'RootK XPrv
--   let accountPubKey  = Shelley 'AccountK XPub
--   let addressPubKey  = Shelley 'PaymentK XPub
--   </pre>
data Shelley (depth :: Depth) key

-- | Extract the raw <a>XPrv</a> or <a>XPub</a> wrapped by this type.
($sel:getKey:Shelley) :: Shelley depth key -> key

-- | Describe what the keys within an account are used for.
--   
--   <ul>
--   <li>UTxOExternal: used for public addresses sent to other parties for
--   receiving money.</li>
--   <li>UTxOInternal: generated by wallet software to send change back to
--   the wallet.</li>
--   <li>Stake: used for stake key(s) and delegation.</li>
--   </ul>
data Role
UTxOExternal :: Role
UTxOInternal :: Role
Stake :: Role

-- | Shelley offers several ways to identify ownership of entities on
--   chain.
--   
--   This data-family has two instances, depending on whether the key is
--   used for payment or for delegation.
data family Credential (purpose :: Depth)

-- | Generate a root key from a corresponding root <a>XPrv</a>
genMasterKeyFromXPrv :: XPrv -> Shelley 'RootK XPrv

-- | Generate a root key from a corresponding mnemonic.
genMasterKeyFromMnemonic :: SomeMnemonic -> ScrubbedBytes -> Shelley 'RootK XPrv

-- | Derives an account private key from the given root private key.
deriveAccountPrivateKey :: Shelley 'RootK XPrv -> Index 'Hardened 'AccountK -> Shelley 'AccountK XPrv

-- | Derives an address private key from the given account private key.
deriveAddressPrivateKey :: Shelley 'AccountK XPrv -> Role -> Index 'Soft 'PaymentK -> Shelley 'PaymentK XPrv

-- | Derive a delegation key for a corresponding <a>AccountK</a>. Note that
--   wallet software are by convention only using one delegation key per
--   account, and always the first account (with index 0').
--   
--   Deriving delegation keys for something else than the initial account
--   is not recommended and can lead to incompatibility with existing
--   wallet softwares (Daedalus, Yoroi, Adalite...).
deriveDelegationPrivateKey :: Shelley 'AccountK XPrv -> Shelley 'DelegationK XPrv

-- | Derives an address public key from the given account public key.
deriveAddressPublicKey :: Shelley 'AccountK XPub -> Role -> Index 'Soft 'PaymentK -> Shelley 'PaymentK XPub

-- | Derives a policy private key from the given root private key.
derivePolicyPrivateKey :: Shelley 'RootK XPrv -> Index 'Hardened 'PolicyK -> Shelley 'PolicyK XPrv

-- | The result of <a>eitherInspectAddress</a>.
data InspectAddress
InspectAddressShelley :: AddressInfo -> InspectAddress
InspectAddressIcarus :: AddressInfo -> InspectAddress
InspectAddressByron :: AddressInfo -> InspectAddress

-- | An inspected Shelley address.
data AddressInfo
AddressInfo :: !Maybe ReferenceInfo -> !Maybe ByteString -> !Maybe ByteString -> !Maybe ByteString -> !Maybe ByteString -> !NetworkTag -> !Word8 -> AddressInfo
[$sel:infoStakeReference:AddressInfo] :: AddressInfo -> !Maybe ReferenceInfo
[$sel:infoSpendingKeyHash:AddressInfo] :: AddressInfo -> !Maybe ByteString
[$sel:infoStakeKeyHash:AddressInfo] :: AddressInfo -> !Maybe ByteString
[$sel:infoScriptHash:AddressInfo] :: AddressInfo -> !Maybe ByteString
[$sel:infoStakeScriptHash:AddressInfo] :: AddressInfo -> !Maybe ByteString
[$sel:infoNetworkTag:AddressInfo] :: AddressInfo -> !NetworkTag
[$sel:infoAddressType:AddressInfo] :: AddressInfo -> !Word8

-- | Info from <a>Address</a> about how delegation keys are located.
data ReferenceInfo
ByValue :: ReferenceInfo
ByPointer :: ChainPointer -> ReferenceInfo

-- | Determines whether an <a>Address</a> is a valid address for the
--   Cardano Shelley era. Shelley format addresses, as well as old-style
--   Byron and Icarus addresses can be parsed by this function.
--   
--   Returns either details about the <a>Address</a>, or
--   <a>ErrInspectAddress</a> if it's not a valid address.
eitherInspectAddress :: Maybe XPub -> Address -> Either ErrInspectAddress InspectAddress

-- | Analyze an <a>Address</a> to know whether it's a valid address for the
--   Cardano Shelley era. Shelley format addresses, as well as old-style
--   Byron and Icarus addresses can be parsed by this function.
--   
--   Returns a JSON value containing details about the <a>Address</a>, or
--   throws <a>ErrInspectAddress</a> if it's not a valid address.
inspectAddress :: (Alternative m, MonadThrow m) => Maybe XPub -> Address -> m Value

-- | Convert a payment credential (key or script) to a payment
--   <a>Address</a> valid for the given network discrimination.
paymentAddress :: NetworkDiscriminant Shelley -> Credential 'PaymentK -> Address

-- | Convert a payment credential (key or script) and a delegation
--   credential (key or script) to a delegation <a>Address</a> valid for
--   the given network discrimination. Funds sent to this address will be
--   delegated according to the delegation settings attached to the
--   delegation key.
delegationAddress :: NetworkDiscriminant Shelley -> Credential 'PaymentK -> Credential 'DelegationK -> Address

-- | Convert a payment credential (key or script) and pointer to delegation
--   certificate in blockchain to a pointer <a>Address</a> valid for the
--   given network discrimination.
pointerAddress :: NetworkDiscriminant Shelley -> Credential 'PaymentK -> ChainPointer -> Address

-- | Convert a delegation credential (key or script) to a stake Address
--   (aka reward account address) for the given network discrimination.
stakeAddress :: NetworkDiscriminant Shelley -> Credential 'DelegationK -> Either ErrInvalidStakeAddress Address

-- | Extend an existing payment <a>Address</a> to make it a delegation
--   address.
extendAddress :: Address -> Credential 'DelegationK -> Either ErrExtendAddress Address

-- | Captures error occuring when trying to extend an invalid address.
data ErrExtendAddress
ErrInvalidAddressStyle :: String -> ErrExtendAddress
ErrInvalidAddressType :: String -> ErrExtendAddress
ErrInvalidKeyHashType :: String -> ErrExtendAddress

-- | Possible errors from inspecting a Shelley address
data ErrInspectAddressOnlyShelley

-- | Human readable error of underlying operation
PtrRetrieveError :: String -> ErrInspectAddressOnlyShelley

-- | Unknown value in address type field
UnknownType :: Word8 -> ErrInspectAddressOnlyShelley

-- | Possible errors from inspecting a Shelley, Icarus, or Byron address.
data ErrInspectAddress

-- | Unexpected size
WrongInputSize :: Int -> ErrInspectAddress
ErrShelley :: ErrInspectAddressOnlyShelley -> ErrInspectAddress
ErrIcarus :: ErrInspectAddress -> ErrInspectAddress
ErrByron :: ErrInspectAddress -> ErrInspectAddress

-- | Pretty-print an <a>ErrInspectAddressOnlyShelley</a>
prettyErrInspectAddressOnlyShelley :: ErrInspectAddressOnlyShelley -> String

-- | Pretty-print an <a>ErrInspectAddress</a>
prettyErrInspectAddress :: ErrInspectAddress -> String

-- | Error reported from trying to create a network discriminant from
--   number
newtype MkNetworkDiscriminantError

-- | Wrong network tag.
ErrWrongNetworkTag :: Integer -> MkNetworkDiscriminantError

-- | Construct <a>NetworkDiscriminant</a> for Cardano <a>Shelley</a> from a
--   number. If the number is invalid, ie., not between 0 and 15, then
--   <a>MkNetworkDiscriminantError</a> is thrown.
mkNetworkDiscriminant :: Integer -> Either MkNetworkDiscriminantError (NetworkDiscriminant Shelley)

-- | Retrieve the network discriminant of a given <a>Address</a>. If the
--   <a>Address</a> is malformed or, not a shelley address, returns
--   Nothing.
inspectNetworkDiscriminant :: Address -> Maybe (NetworkDiscriminant Shelley)

-- | <tt>NetworkDicriminant</tt> for Cardano MainNet &amp; Shelley
shelleyMainnet :: NetworkDiscriminant Shelley

-- | <tt>NetworkDicriminant</tt> for Cardano Testnet &amp; Shelley
shelleyTestnet :: NetworkDiscriminant Shelley

-- | Unsafe backdoor for constructing an <a>Shelley</a> key from a raw
--   <a>XPrv</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPrv :: XPrv -> Shelley depth XPrv

-- | Unsafe backdoor for constructing an <a>Shelley</a> key from a raw
--   <a>XPub</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPub :: XPub -> Shelley depth XPub

-- | Unsafe backdoor for constructing an <a>Shelley</a> key from a raw
--   <a>Pub</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftPub :: Pub -> Shelley depth Pub
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Address.Style.Shelley.Shelley depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Address.Style.Shelley.Shelley depth key)
instance GHC.Generics.Generic (Cardano.Address.Style.Shelley.Shelley depth key)
instance GHC.Enum.Bounded Cardano.Address.Style.Shelley.Role
instance GHC.Classes.Ord Cardano.Address.Style.Shelley.Role
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.Role
instance GHC.Show.Show Cardano.Address.Style.Shelley.Role
instance GHC.Generics.Generic Cardano.Address.Style.Shelley.Role
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Style.Shelley.ErrInspectAddressOnlyShelley
instance GHC.Show.Show Cardano.Address.Style.Shelley.ErrInspectAddressOnlyShelley
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.ErrInspectAddressOnlyShelley
instance GHC.Generics.Generic Cardano.Address.Style.Shelley.ErrInspectAddressOnlyShelley
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Style.Shelley.ErrInspectAddress
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.ErrInspectAddress
instance GHC.Show.Show Cardano.Address.Style.Shelley.ErrInspectAddress
instance GHC.Generics.Generic Cardano.Address.Style.Shelley.ErrInspectAddress
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.ReferenceInfo
instance GHC.Show.Show Cardano.Address.Style.Shelley.ReferenceInfo
instance GHC.Generics.Generic Cardano.Address.Style.Shelley.ReferenceInfo
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.AddressInfo
instance GHC.Show.Show Cardano.Address.Style.Shelley.AddressInfo
instance GHC.Generics.Generic Cardano.Address.Style.Shelley.AddressInfo
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.InspectAddress
instance GHC.Show.Show Cardano.Address.Style.Shelley.InspectAddress
instance GHC.Generics.Generic Cardano.Address.Style.Shelley.InspectAddress
instance GHC.Show.Show Cardano.Address.Style.Shelley.AddressParts
instance GHC.Show.Show (Cardano.Address.Style.Shelley.Credential 'Cardano.Address.Derivation.PaymentK)
instance GHC.Show.Show (Cardano.Address.Style.Shelley.Credential 'Cardano.Address.Derivation.DelegationK)
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.ErrInvalidStakeAddress
instance GHC.Show.Show Cardano.Address.Style.Shelley.ErrInvalidStakeAddress
instance GHC.Generics.Generic Cardano.Address.Style.Shelley.ErrInvalidStakeAddress
instance GHC.Show.Show Cardano.Address.Style.Shelley.ErrExtendAddress
instance GHC.Show.Show Cardano.Address.Style.Shelley.MkNetworkDiscriminantError
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.MkNetworkDiscriminantError
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.CredentialType
instance GHC.Show.Show Cardano.Address.Style.Shelley.CredentialType
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.AddressType
instance GHC.Show.Show Cardano.Address.Style.Shelley.AddressType
instance GHC.Base.Functor (Cardano.Address.Style.Shelley.Shelley depth)
instance Formatting.Buildable.Buildable Cardano.Address.Style.Shelley.MkNetworkDiscriminantError
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Style.Shelley.InspectAddress
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Style.Shelley.AddressInfo
instance GHC.Exception.Type.Exception Cardano.Address.Style.Shelley.ErrInspectAddress
instance GHC.Exception.Type.Exception Cardano.Address.Style.Shelley.ErrInspectAddressOnlyShelley
instance Control.DeepSeq.NFData Cardano.Address.Style.Shelley.Role
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Shelley.Shelley
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Address.Style.Shelley.Shelley depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Shelley.Shelley
instance Cardano.Address.Derivation.SoftDerivation Cardano.Address.Style.Shelley.Shelley
instance Cardano.Address.HasNetworkDiscriminant Cardano.Address.Style.Shelley.Shelley


module Cardano.Address.Style.Shared

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types. The derivation is mostly like
--   Shelley, except the used purpose index (here 1854H rather than
--   Shelley's 1852H)
--   
--   <pre>
--   let rootPrivateKey = Shared 'RootK XPrv
--   let accountPubKey  = Shared 'AccountK XPub
--   let addressPubKey  = Shared 'PaymentK XPub
--   </pre>
data Shared (depth :: Depth) key

-- | Extract the raw <a>XPrv</a> or <a>XPub</a> wrapped by this type.
getKey :: Shared depth key -> key

-- | Unsafe backdoor for constructing an <a>Shared</a> key from a raw
--   <a>XPrv</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPrv :: XPrv -> Shared depth XPrv

-- | Unsafe backdoor for constructing an <a>Shared</a> key from a raw
--   <a>XPub</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPub :: XPub -> Shared depth XPub

-- | Calculates wallet id of shared wallet It takes raw bytes of account
--   public kye (64-bytes), spending script template, and optionally
--   staking script template.
sharedWalletId :: ByteString -> Script Cosigner -> Maybe (Script Cosigner) -> ByteString

-- | Generate a root key from a corresponding root <a>XPrv</a>
genMasterKeyFromXPrv :: XPrv -> Shared 'RootK XPrv

-- | Generate a root key from a corresponding mnemonic.
genMasterKeyFromMnemonic :: SomeMnemonic -> ScrubbedBytes -> Shared 'RootK XPrv

-- | Derives an account private key from the given root private key.
deriveAccountPrivateKey :: Shared 'RootK XPrv -> Index 'Hardened 'AccountK -> Shared 'AccountK XPrv

-- | Derives a multisig private key from the given account private key for
--   payment credential.
deriveAddressPrivateKey :: Shared 'AccountK XPrv -> Role -> Index 'Soft 'PaymentK -> Shared 'ScriptK XPrv

-- | Derives a multisig public key from the given account public key for
--   payment credential.
deriveAddressPublicKey :: Shared 'AccountK XPub -> Role -> Index 'Soft 'PaymentK -> Shared 'ScriptK XPub

-- | Derives a multisig private key from the given account private key for
--   delegation credential.
deriveDelegationPrivateKey :: Shared 'AccountK XPrv -> Index 'Soft 'PaymentK -> Shared 'ScriptK XPrv

-- | Derives a multisig public key from the given account public key for
--   delegation credential.
deriveDelegationPublicKey :: Shared 'AccountK XPub -> Index 'Soft 'PaymentK -> Shared 'ScriptK XPub
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Address.Style.Shared.Shared depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Address.Style.Shared.Shared depth key)
instance GHC.Generics.Generic (Cardano.Address.Style.Shared.Shared depth key)
instance GHC.Base.Functor (Cardano.Address.Style.Shared.Shared depth)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Address.Style.Shared.Shared depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Shared.Shared
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Shared.Shared
instance Cardano.Address.Derivation.SoftDerivation Cardano.Address.Style.Shared.Shared
