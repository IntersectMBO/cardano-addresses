-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library utilities for mnemonic generation and address derivation.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/cardano-addresses</a>
@package cardano-addresses
@version 3.1.1


-- | List common bech32 prefixes used for objects in the Cardano
--   eco-systems.
--   
--   As specified in <a>CIP-5</a>
module Cardano.Codec.Bech32.Prefixes
addr :: HumanReadablePart
addr_test :: HumanReadablePart
script :: HumanReadablePart
stake :: HumanReadablePart
stake_test :: HumanReadablePart
addr_vkh :: HumanReadablePart
script_vkh :: HumanReadablePart
stake_vkh :: HumanReadablePart
addr_vk :: HumanReadablePart
addr_sk :: HumanReadablePart
addr_xvk :: HumanReadablePart
addr_xsk :: HumanReadablePart
acct_vk :: HumanReadablePart
acct_sk :: HumanReadablePart
acct_xvk :: HumanReadablePart
acct_xsk :: HumanReadablePart
root_vk :: HumanReadablePart
root_sk :: HumanReadablePart
root_xvk :: HumanReadablePart
root_xsk :: HumanReadablePart
script_vk :: HumanReadablePart
script_sk :: HumanReadablePart
script_xvk :: HumanReadablePart
script_xsk :: HumanReadablePart
stake_vk :: HumanReadablePart
stake_sk :: HumanReadablePart
stake_xvk :: HumanReadablePart
stake_xsk :: HumanReadablePart

module Cardano.Mnemonic

-- | Ease the manipulation of <a>Mnemonic</a> by encapsulating the type
--   constraints inside a constructor. This is particularly useful for
--   functions which do not require anything but a valid <a>Mnemonic</a>
--   without any particular pre-condition on the size of the
--   <a>Mnemonic</a> itself.
data SomeMnemonic
[SomeMnemonic] :: forall mw. KnownNat mw => Mnemonic mw -> SomeMnemonic

-- | This class enables caller to parse text list of variable length into
--   mnemonic sentences.
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
class MkSomeMnemonic (sz :: [Nat])

-- | Construct a mnemonic from a list of words. This function is
--   particularly useful when the number of words is not necessarily known
--   at runtime. The function is however <i>ambiguous</i> and requires
--   thereby a type application.
--   
--   <b>examples:</b>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 12 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Left "Invalid number of words: 12 words are expected."
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mkSomeMnemonic @'[ 9, 12, 15 ] [ "test", "child", "burst", "immense", "armed", "parrot", "company", "walk", "dog" ]
--   Right (SomeMnemonic ...)
--   </pre>
mkSomeMnemonic :: MkSomeMnemonic sz => [Text] -> Either (MkSomeMnemonicError sz) SomeMnemonic

-- | Error reported from trying to create a passphrase from a given
--   mnemonic
newtype MkSomeMnemonicError (sz :: [Nat])
MkSomeMnemonicError :: String -> MkSomeMnemonicError
[getMkSomeMnemonicError] :: MkSomeMnemonicError -> String

-- | Convert a <a>SomeMnemonic</a> to bytes.
someMnemonicToBytes :: SomeMnemonic -> ScrubbedBytes

-- | Small helper to collect <a>Nat</a> values from a type-level list
class NatVals (ns :: [Nat])
natVals :: NatVals ns => Proxy ns -> [Integer]

-- | Smart-constructor for <a>Mnemonic</a>. Requires a type application to
--   disambiguate the mnemonic size.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkMnemonic @15 sentence
--   Mnemonic {} :: Mnemonic 15
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkMnemonic (mnemonicToText mnemonic) == Right mnemonic
--   </pre>
mkMnemonic :: forall (mw :: Nat) (ent :: Nat) csz. (ConsistentEntropy ent mw csz, EntropySize mw ~ ent) => [Text] -> Either (MkMnemonicError csz) (Mnemonic mw)

-- | This wraps errors from <a>Cardano.Encoding.BIP39</a>
data MkMnemonicError csz

-- | Wrong number of words in mnemonic.
ErrMnemonicWords :: MnemonicWordsError -> MkMnemonicError csz

-- | Invalid entropy length or checksum.
ErrEntropy :: EntropyError csz -> MkMnemonicError csz

-- | Invalid word in mnemonic.
ErrDictionary :: DictionaryError -> MkMnemonicError csz

-- | Convert a <a>Mnemonic</a> to a sentence of English mnemonic words.
mnemonicToText :: Mnemonic mw -> [Text]

-- | Convert a <a>Mnemonic</a> back to an <a>Entropy</a>.
mnemonicToEntropy :: Mnemonic mw -> Entropy (EntropySize mw)

-- | Generate Entropy of a given size using a cryptographically secure
--   random seed.
--   
--   <b>example:</b>
--   
--   <pre>
--   &gt;&gt;&gt; genEntropy @128
--   Entropy {} :: Entropy 128
--   </pre>
genEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => IO (Entropy ent)

-- | Smart-constructor for the <a>Entropy</a>. Make sure the
--   <tt>ByteString</tt> comes from a highly random source or use
--   <a>genEntropy</a>.
--   
--   <b>example</b>:
--   
--   <pre>
--   &gt;&gt;&gt; mkEntropy @160 bytes
--   Entropy {} :: Entropy 160
--   </pre>
--   
--   <b>property</b>:
--   
--   <pre>
--   mkEntropy (entropyToBytes ent) == Right ent
--   </pre>
mkEntropy :: forall (ent :: Nat) csz. (ValidEntropySize ent, ValidChecksumSize ent csz) => ScrubbedBytes -> Either (EntropyError csz) (Entropy ent)

-- | Convert <a>Entropy</a> to plain bytes.
entropyToBytes :: Entropy n -> ScrubbedBytes

-- | Convert an Entropy to a corresponding Mnemonic Sentence. Since
--   <a>Entropy</a> and <a>Mnemonic</a> can only be created through
--   smart-constructors, this function cannot fail and is total.
entropyToMnemonic :: forall mw ent csz. (ValidMnemonicSentence mw, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Entropy ent -> Mnemonic mw
instance GHC.Show.Show (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkSomeMnemonicError sz)
instance GHC.Show.Show (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Classes.Eq (Cardano.Mnemonic.MkMnemonicError csz)
instance GHC.Show.Show (Cardano.Mnemonic.MnemonicException csz)
instance GHC.Show.Show (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Cardano.Mnemonic.Mnemonic mw)
instance GHC.Classes.Eq (Crypto.Encoding.BIP39.EntropyError czs)
instance GHC.Classes.Eq Crypto.Encoding.BIP39.MnemonicWordsError
instance GHC.Classes.Eq Crypto.Encoding.BIP39.Dictionary.DictionaryError
instance GHC.Show.Show Cardano.Mnemonic.SomeMnemonic
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz, Cardano.Mnemonic.MkSomeMnemonic rest, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.MkSomeMnemonic (mw : rest)
instance Cardano.Mnemonic.NatVals '[]
instance (GHC.TypeNats.KnownNat n, Cardano.Mnemonic.NatVals rest) => Cardano.Mnemonic.NatVals (n : rest)
instance (n Data.Type.Equality.~ Crypto.Encoding.BIP39.EntropySize mw, csz Data.Type.Equality.~ Crypto.Encoding.BIP39.CheckSumBits n, Crypto.Encoding.BIP39.ConsistentEntropy n mw csz) => Cardano.Mnemonic.MkSomeMnemonic '[mw]
instance GHC.Classes.Eq Cardano.Mnemonic.SomeMnemonic
instance GHC.TypeNats.KnownNat csz => GHC.Exception.Type.Exception (Cardano.Mnemonic.MnemonicException csz)

module Cardano.Address.Derivation

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'PaymentK
--   </pre>
data Index (derivationType :: DerivationType) (depth :: Depth)

-- | Key Depth in the derivation path, according to BIP-0039 / BIP-0044
--   
--   <pre>
--   root | purpose' | cointype' | account' | role | address@
--   0th      1st         2nd        3rd       4th     5th
--   </pre>
--   
--   We do not manipulate purpose, cointype and change paths directly, so
--   there are no constructors for these.
data Depth
RootK :: Depth
AccountK :: Depth
PaymentK :: Depth
DelegationK :: Depth
ScriptK :: Depth

-- | Type of derivation that should be used with the given indexes.
--   
--   In theory, we should only consider two derivation types: soft and
--   hard.
--   
--   However, historically, addresses in Cardano used to be generated
--   across both the soft and the hard domain. We therefore introduce a
--   <a>WholeDomain</a> derivation type that is the exact union of
--   <a>Hardened</a> and <a>Soft</a>.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType
WholeDomain :: DerivationType

-- | Abstract interface for constructing a <i>Master Key</i>.
class GenMasterKey (key :: Depth -> * -> *) where {
    type family SecondFactor key :: *;
}

-- | Generate a root key from a corresponding mnemonic.
genMasterKeyFromMnemonic :: GenMasterKey key => SomeMnemonic -> SecondFactor key -> key  'RootK XPrv

-- | Generate a root key from a corresponding root <a>XPrv</a>
genMasterKeyFromXPrv :: GenMasterKey key => XPrv -> key  'RootK XPrv

-- | An interface for doing hard derivations from the root private key,
--   <i>Master Key</i>
class HardDerivation (key :: Depth -> * -> *) where {
    type family AccountIndexDerivationType key :: DerivationType;
    type family AddressIndexDerivationType key :: DerivationType;
    type family WithRole key :: *;
}

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAccountPrivateKey :: HardDerivation key => key  'RootK XPrv -> Index (AccountIndexDerivationType key)  'AccountK -> key  'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
deriveAddressPrivateKey :: HardDerivation key => key  'AccountK XPrv -> WithRole key -> Index (AddressIndexDerivationType key)  'PaymentK -> key  'PaymentK XPrv

-- | An interface for doing soft derivations from an account public key
class HardDerivation key => SoftDerivation (key :: Depth -> * -> *)

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: SoftDerivation key => key  'AccountK XPub -> WithRole key -> Index  'Soft  'PaymentK -> key  'PaymentK XPub

-- | An opaque type representing an extended private key.
--   
--   <b>Properties:</b>
--   
--   <h5>Roundtripping</h5>
--   
--   <pre>
--   forall xprv. <a>xprvFromBytes</a> (<a>xprvToBytes</a> xprv) == <a>Just</a> xprv
--   </pre>
--   
--   <h5>Chain Code Invariance</h5>
--   
--   <pre>
--   forall xprv. <a>xprvChainCode</a> xprv == <a>xpubChainCode</a> (<a>toXPub</a> xprv)
--   </pre>
--   
--   <h5>Public Key Signature</h5>
--   
--   <pre>
--   forall xprv msg. <a>verify</a> (<a>toXPub</a> xprv) msg (<a>sign</a> xprv msg) == <a>True</a>
--   </pre>
type XPrv = XPrv

-- | Construct an <a>XPrv</a> from raw <a>ByteString</a> (96 bytes).
xprvFromBytes :: ByteString -> Maybe XPrv

-- | Convert an <a>XPrv</a> to a raw <a>ByteString</a> (96 bytes).
xprvToBytes :: XPrv -> ByteString

-- | Extract the private key from an <a>XPrv</a> as a raw <a>ByteString</a>
--   (64 bytes).
xprvPrivateKey :: XPrv -> ByteString

-- | Extract the chain code from an <a>XPrv</a> as a raw <a>ByteString</a>
--   (32 bytes).
xprvChainCode :: XPrv -> ByteString

-- | Derive the <a>XPub</a> associated with an <a>XPrv</a>.
toXPub :: HasCallStack => XPrv -> XPub

-- | An opaque type representing an extended public key.
--   
--   <b>Properties:</b>
--   
--   <h5>Roundtripping</h5>
--   
--   <pre>
--   forall xpub. <a>xpubFromBytes</a> (<a>xpubToBytes</a> xpub) == <a>Just</a> xpub
--   </pre>
type XPub = XPub

-- | Construct an <a>XPub</a> from raw <a>ByteString</a> (64 bytes).
xpubFromBytes :: ByteString -> Maybe XPub

-- | Convert an <a>XPub</a> to a raw <a>ByteString</a> (64 bytes).
xpubToBytes :: XPub -> ByteString

-- | Extract the public key from an <a>XPub</a> as a raw <a>ByteString</a>
--   (32 bytes).
xpubPublicKey :: XPub -> ByteString

-- | Extract the chain code from an <a>XPub</a> as a raw <a>ByteString</a>
--   (32 bytes).
xpubChainCode :: XPub -> ByteString

-- | An opaque type representing a signature made from an <a>XPrv</a>.
type XSignature = XSignature

-- | Produce a signature of the given <tt>msg</tt> from an <a>XPrv</a>.
sign :: ByteArrayAccess msg => XPrv -> msg -> XSignature

-- | Verify the <a>XSignature</a> of a <tt>msg</tt> with the <a>XPub</a>
--   associated with the <a>XPrv</a> used for signing.
verify :: ByteArrayAccess msg => XPub -> msg -> XSignature -> Bool
instance GHC.Classes.Ord (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Classes.Eq (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Show.Show (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Generics.Generic (Cardano.Address.Derivation.Index derivationType depth)
instance Control.DeepSeq.NFData (Cardano.Address.Derivation.Index derivationType depth)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Hardened depth)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Soft depth)
instance GHC.Enum.Bounded (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.WholeDomain depth)
instance GHC.Enum.Enum (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Hardened depth)
instance GHC.Enum.Enum (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.Soft depth)
instance GHC.Enum.Enum (Cardano.Address.Derivation.Index 'Cardano.Address.Derivation.WholeDomain depth)
instance Formatting.Buildable.Buildable (Cardano.Address.Derivation.Index derivationType depth)

module Cardano.Address.Script

-- | A <a>Script</a> type represents multi signature script. The script
--   embodies conditions that need to be satisfied to make it valid.
data Script
RequireSignatureOf :: !KeyHash -> Script
RequireAllOf :: ![Script] -> Script
RequireAnyOf :: ![Script] -> Script
RequireSomeOf :: Word8 -> ![Script] -> Script

-- | This function realizes what cardano-node's `Api.serialiseToCBOR
--   script` realizes This is basically doing the symbolically following:
--   toCBOR [0,multisigScript]
serializeScript :: Script -> ByteString

-- | Validate a <a>Script</a>, semantically
validateScript :: Script -> Either ErrValidateScript ()

-- | Possible validation errors when validating a script
data ErrValidateScript
EmptyList :: ErrValidateScript
ListTooSmall :: ErrValidateScript
MZero :: ErrValidateScript
DuplicateSignatures :: ErrValidateScript
WrongKeyHash :: ErrValidateScript
Malformed :: ErrValidateScript

-- | Pretty-print a validation error.
prettyErrValidateScript :: ErrValidateScript -> String

-- | A <a>ScriptHash</a> type represents script hash. The hash is expected
--   to have size of 28-byte.
newtype ScriptHash
ScriptHash :: ByteString -> ScriptHash
[unScriptHash] :: ScriptHash -> ByteString

-- | Computes the hash of a given script, by first serializing it to CBOR.
toScriptHash :: Script -> ScriptHash

-- | Construct an <a>ScriptHash</a> from raw <a>ByteString</a> (28 bytes).
scriptHashFromBytes :: ByteString -> Maybe ScriptHash

-- | A <a>KeyHash</a> type represents verification key hash that
--   participate in building multi-signature script. The hash is expected
--   to have size of 28-byte.
newtype KeyHash
KeyHash :: ByteString -> KeyHash
[unKeyHash] :: KeyHash -> ByteString

-- | Construct an <a>KeyHash</a> from raw <a>ByteString</a> (28 bytes).
keyHashFromBytes :: ByteString -> Maybe KeyHash

-- | Construct a <a>KeyHash</a> from <a>Text</a>. Either hex encoded text
--   or Bech32 encoded text with <tt>script_vkh</tt>, <tt>script_vk</tt> or
--   <tt>script_xvk</tt> hrp are expected. Raw keys will be hashed on the
--   fly, whereas hash that are directly provided will remain as such.
keyHashFromText :: Text -> Either ErrKeyHashFromText KeyHash

-- | Encode a <a>KeyHash</a> to bech32 <a>Text</a>, using
--   <tt>script_vkh</tt> as a human readable prefix.
keyHashToText :: KeyHash -> Text
instance GHC.Show.Show Cardano.Address.Script.ErrValidateScript
instance GHC.Classes.Eq Cardano.Address.Script.ErrValidateScript
instance GHC.Classes.Eq Cardano.Address.Script.ErrKeyHashFromText
instance GHC.Show.Show Cardano.Address.Script.ErrKeyHashFromText
instance GHC.Classes.Eq Cardano.Address.Script.Script
instance GHC.Show.Show Cardano.Address.Script.Script
instance GHC.Generics.Generic Cardano.Address.Script.Script
instance GHC.Classes.Eq Cardano.Address.Script.KeyHash
instance GHC.Show.Show Cardano.Address.Script.KeyHash
instance GHC.Generics.Generic Cardano.Address.Script.KeyHash
instance GHC.Classes.Eq Cardano.Address.Script.ScriptHash
instance GHC.Show.Show Cardano.Address.Script.ScriptHash
instance GHC.Generics.Generic Cardano.Address.Script.ScriptHash
instance Control.DeepSeq.NFData Cardano.Address.Script.Script
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Address.Script.Script
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Address.Script.Script
instance Control.DeepSeq.NFData Cardano.Address.Script.KeyHash
instance Control.DeepSeq.NFData Cardano.Address.Script.ScriptHash

module Cardano.Address.Script.Parser

-- | Run <a>scriptParser</a> on string input.
scriptFromString :: String -> Either ErrValidateScript Script

-- | The script embodies combination of signing keys that need to be met to
--   make it valid. We assume here that the script could delivered from
--   standard input. The examples below are self-explanatory:
--   
--   <ol>
--   <li>requiring signature
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe</li>
--   <li><a>any</a> for signature required any
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe,
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1]</li>
--   <li><a>all</a> signatures required all
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe,
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1]</li>
--   <li><tt>at_least</tt> 1 signature required at_least 1
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe,
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1]</li>
--   <li>Nested script are supported at_least 1
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3fe, all
--   [3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1,
--   3c07030e36bfffe67e2e2ec09e5293d384637cd2f004356ef320f3f1]]</li>
--   </ol>
--   
--   Parser is insensitive to whitespaces.
scriptParser :: ReadP Script

-- | Validate a <a>Script</a>, semantically
validateScript :: Script -> Either ErrValidateScript ()

-- | Possible validation errors when validating a script
data ErrValidateScript
EmptyList :: ErrValidateScript
ListTooSmall :: ErrValidateScript
MZero :: ErrValidateScript
DuplicateSignatures :: ErrValidateScript
WrongKeyHash :: ErrValidateScript
Malformed :: ErrValidateScript

-- | Pretty-print a validation error.
prettyErrValidateScript :: ErrValidateScript -> String

module Cardano.Address

-- | An <a>Address</a> type representing <tt>Cardano</tt> addresses.
--   Internals are irrevelant to the user.
data Address

-- | Encoding of addresses for certain key types and backend targets.
class HasNetworkDiscriminant key => PaymentAddress key

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
paymentAddress :: PaymentAddress key => NetworkDiscriminant key -> key  'PaymentK XPub -> Address

-- | Encoding of addresses for certain key types and backend targets.
class HasNetworkDiscriminant key => StakeAddress key

-- | Convert a delegation key to a stake <a>Address</a> (aka: reward
--   account address) valid for the given network discrimination.
stakeAddress :: StakeAddress key => NetworkDiscriminant key -> key  'DelegationK XPub -> Address

-- | Encoding of delegation addresses for certain key types and backend
--   targets.
class PaymentAddress key => DelegationAddress key

-- | Convert a public key and a delegation key to a delegation
--   <a>Address</a> valid for the given network discrimination. Funds sent
--   to this address will be delegated according to the delegation settings
--   attached to the delegation key.
delegationAddress :: DelegationAddress key => NetworkDiscriminant key -> key  'PaymentK XPub -> key  'DelegationK XPub -> Address

-- | Encoding of pointer addresses for payment key type, pointer to
--   delegation certificate in the blockchain and backend targets.
class PaymentAddress key => PointerAddress key

-- | Convert a payment public key and a pointer to delegation key in the
--   blockchain to a delegation <a>Address</a> valid for the given network
--   discrimination. Funds sent to this address will be delegated according
--   to the delegation settings attached to the delegation key located by
--   <a>ChainPointer</a>.
pointerAddress :: PointerAddress key => NetworkDiscriminant key -> key  'PaymentK XPub -> ChainPointer -> Address

-- | A <a>ChainPointer</a> type representing location of some object in the
--   blockchain (eg., delegation certificate). This can be achieved
--   unambiguously by specifying slot number, transaction index and the
--   index in the object list (eg., certification list). For delegation
--   certificates, alternatively, the delegation key can be used and then
--   <a>DelegationAddress</a> can be used.
data ChainPointer
ChainPointer :: Natural -> Natural -> Natural -> ChainPointer

-- | Pointer to the slot
[slotNum] :: ChainPointer -> Natural

-- | transaction index
[transactionIndex] :: ChainPointer -> Natural

-- | output list index
[outputIndex] :: ChainPointer -> Natural

-- | Encode an <a>Address</a> to a base58 <a>Text</a>.
base58 :: Address -> Text

-- | Decode a base58-encoded <a>Text</a> into an <a>Address</a>
fromBase58 :: Text -> Maybe Address

-- | Encode an <a>Address</a> to bech32 <a>Text</a>, using <tt>addr</tt> as
--   a human readable prefix.
bech32 :: Address -> Text

-- | Encode an <a>Address</a> to bech32 <a>Text</a>, using a specified
--   human readable prefix.
bech32With :: HumanReadablePart -> Address -> Text

-- | Decode a bech32-encoded <a>Text</a> into an <a>Address</a>
fromBech32 :: Text -> Maybe Address
instance GHC.Classes.Eq Cardano.Address.AddressDiscrimination
instance GHC.Show.Show Cardano.Address.AddressDiscrimination
instance GHC.Generics.Generic Cardano.Address.AddressDiscrimination
instance GHC.Classes.Eq Cardano.Address.NetworkTag
instance GHC.Show.Show Cardano.Address.NetworkTag
instance GHC.Generics.Generic Cardano.Address.NetworkTag
instance GHC.Classes.Ord Cardano.Address.ChainPointer
instance GHC.Classes.Eq Cardano.Address.ChainPointer
instance GHC.Show.Show Cardano.Address.ChainPointer
instance GHC.Generics.Generic Cardano.Address.ChainPointer
instance GHC.Classes.Ord Cardano.Address.Address
instance GHC.Classes.Eq Cardano.Address.Address
instance GHC.Show.Show Cardano.Address.Address
instance GHC.Generics.Generic Cardano.Address.Address
instance Control.DeepSeq.NFData Cardano.Address.AddressDiscrimination
instance Control.DeepSeq.NFData Cardano.Address.NetworkTag
instance Control.DeepSeq.NFData Cardano.Address.ChainPointer
instance Control.DeepSeq.NFData Cardano.Address.Address


module Cardano.Address.Style.Byron

-- | Material for deriving HD random scheme keys, which can be used for
--   making addresses.

-- | <i>Deprecated: see <a>Icarus</a></i>
data Byron (depth :: Depth) key

-- | The hierarchical derivation indices for a given level/depth.

-- | <i>Deprecated: see <a>Icarus</a></i>
type family DerivationPath (depth :: Depth) :: *

-- | Used for encryption of the derivation path payload within an address.

-- | <i>Deprecated: see <a>Icarus</a></i>
payloadPassphrase :: Byron depth key -> ScrubbedBytes

-- | The address derivation indices for the level of this key.

-- | <i>Deprecated: see <a>Icarus</a></i>
derivationPath :: Byron depth key -> DerivationPath depth

-- | The raw private or public key.

-- | <i>Deprecated: see <a>Icarus</a></i>
getKey :: Byron depth key -> key

-- | Generate a root key from a corresponding root <a>XPrv</a>

-- | <i>Deprecated: see <a>Icarus</a></i>
genMasterKeyFromXPrv :: XPrv -> Byron  'RootK XPrv

-- | Generate a root key from a corresponding mnemonic.

-- | <i>Deprecated: see <a>Icarus</a></i>
genMasterKeyFromMnemonic :: SomeMnemonic -> Byron  'RootK XPrv

-- | Derives an account private key from the given root private key.

-- | <i>Deprecated: see <a>Icarus</a></i>
deriveAccountPrivateKey :: Byron  'RootK XPrv -> Index  'WholeDomain  'AccountK -> Byron  'AccountK XPrv

-- | Derives an address private key from the given account private key.

-- | <i>Deprecated: see <a>Icarus</a></i>
deriveAddressPrivateKey :: Byron  'AccountK XPrv -> Index  'WholeDomain  'PaymentK -> Byron  'PaymentK XPrv

-- | Analyze an <a>Address</a> to know whether it's a Byron address or not.
--   Throws <tt>ByronAddrError</tt> if the address isn't a byron address,
--   or return a structured JSON that gives information about an address.
inspectAddress :: forall m. MonadThrow m => Maybe XPub -> Address -> m Value

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
paymentAddress :: NetworkDiscriminant Byron -> Byron  'PaymentK XPub -> Address

-- | Possible errors from inspecting a Byron address
data ErrInspectAddress
MissingExpectedDerivationPath :: ErrInspectAddress
DeserialiseError :: e -> ErrInspectAddress
FailedToDecryptPath :: ErrInspectAddress

-- | Pretty-print an <a>ErrInspectAddress</a>
prettyErrInspectAddress :: ErrInspectAddress -> String

-- | <a>NetworkDiscriminant</a> for Cardano MainNet &amp; Byron
byronMainnet :: NetworkDiscriminant Byron

-- | <a>NetworkDiscriminant</a> for Cardano Staging &amp; Byron
byronStaging :: NetworkDiscriminant Byron

-- | <a>NetworkDiscriminant</a> for Cardano TestNet &amp; Byron
byronTestnet :: NetworkDiscriminant Byron

-- | Backdoor for generating a new key from a raw <a>XPrv</a>.
--   
--   Note that the <tt>depth</tt> is left open so that the caller gets to
--   decide what type of key this is. This is mostly for testing, in
--   practice, seeds are used to represent root keys, and one should
--   <a>genMasterKeyFromXPrv</a>
--   
--   The first argument is a type-family <a>DerivationPath</a> and its type
--   depends on the <tt>depth</tt> of the key.
--   
--   <b>examples:</b>
--   
--   <pre>
--   &gt;&gt;&gt; liftXPrv rootPrv () prv
--   _ :: Byron RootK XPrv
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftXPrv rootPrv minBound prv
--   _ :: Byron AccountK XPrv
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; liftXPrv rootPrv (minBound, minBound) prv
--   _ :: Byron PaymentK XPrv
--   </pre>

-- | <i>Deprecated: see <a>Icarus</a></i>
liftXPrv :: XPub -> DerivationPath depth -> XPrv -> Byron depth XPrv

-- | Backdoor for generating a new key from a raw <a>XPub</a>.
--   
--   Note that the <tt>depth</tt> is left open so that the caller gets to
--   decide what type of key this is. This is mostly for testing, in
--   practice, seeds are used to represent root keys, and one should
--   <a>genMasterKeyFromXPrv</a>
--   
--   see also <a>liftXPrv</a>

-- | <i>Deprecated: see <a>Icarus</a></i>
liftXPub :: XPub -> DerivationPath depth -> XPub -> Byron depth XPub
instance GHC.Generics.Generic (Cardano.Address.Style.Byron.Byron depth key)
instance (GHC.Show.Show key, GHC.Show.Show (Cardano.Address.Style.Byron.DerivationPath depth)) => GHC.Show.Show (Cardano.Address.Style.Byron.Byron depth key)
instance (GHC.Classes.Eq key, GHC.Classes.Eq (Cardano.Address.Style.Byron.DerivationPath depth)) => GHC.Classes.Eq (Cardano.Address.Style.Byron.Byron depth key)
instance GHC.Base.Functor (Cardano.Address.Style.Byron.Byron depth)
instance GHC.Show.Show Cardano.Address.Style.Byron.ErrInspectAddress
instance GHC.Exception.Type.Exception Cardano.Address.Style.Byron.ErrInspectAddress
instance (Control.DeepSeq.NFData key, Control.DeepSeq.NFData (Cardano.Address.Style.Byron.DerivationPath depth)) => Control.DeepSeq.NFData (Cardano.Address.Style.Byron.Byron depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Byron.Byron
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Byron.Byron
instance Cardano.Address.PaymentAddress Cardano.Address.Style.Byron.Byron
instance Cardano.Address.HasNetworkDiscriminant Cardano.Address.Style.Byron.Byron


module Cardano.Address.Style.Icarus

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Icarus 'RootK XPrv
--   let accountPubKey  = Icarus 'AccountK XPub
--   let addressPubKey  = Icarus 'PaymentK XPub
--   </pre>
data Icarus (depth :: Depth) key

-- | Extract the raw <a>XPrv</a> or <a>XPub</a> wrapped by this type.
getKey :: Icarus depth key -> key

-- | Generate a root key from a corresponding root <a>XPrv</a>
genMasterKeyFromXPrv :: XPrv -> Icarus  'RootK XPrv

-- | Generate a root key from a corresponding mnemonic.
genMasterKeyFromMnemonic :: SomeMnemonic -> ScrubbedBytes -> Icarus  'RootK XPrv

-- | Derives an account private key from the given root private key.
deriveAccountPrivateKey :: Icarus  'RootK XPrv -> Index  'Hardened  'AccountK -> Icarus  'AccountK XPrv

-- | Derives an address private key from the given account private key.
deriveAddressPrivateKey :: Icarus  'AccountK XPrv -> Role -> Index  'Soft  'PaymentK -> Icarus  'PaymentK XPrv

-- | Derives an address public key from the given account public key.
deriveAddressPublicKey :: Icarus  'AccountK XPub -> Role -> Index  'Soft  'PaymentK -> Icarus  'PaymentK XPub

-- | Analyze an <a>Address</a> to know whether it's an Icarus address or
--   not. Throws <tt>IcarusAddrError</tt> if the address isn't a byron
--   address, or return a structured JSON that gives information about an
--   address.
inspectAddress :: MonadThrow m => Address -> m Value

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
paymentAddress :: NetworkDiscriminant Icarus -> Icarus  'PaymentK XPub -> Address

-- | Possible errors from inspecting a Shelley address
data ErrInspectAddress

-- | Pretty-print an <a>ErrInspectAddress</a>
prettyErrInspectAddress :: ErrInspectAddress -> String

-- | <a>NetworkDiscriminant</a> for Cardano MainNet &amp; <a>Icarus</a>
icarusMainnet :: NetworkDiscriminant Icarus

-- | <a>NetworkDiscriminant</a> for Cardano Staging &amp; <a>Icarus</a>
icarusStaging :: NetworkDiscriminant Icarus

-- | <a>NetworkDiscriminant</a> for Cardano TestNet &amp; <a>Icarus</a>
icarusTestnet :: NetworkDiscriminant Icarus

-- | Unsafe backdoor for constructing an <a>Icarus</a> key from a raw
--   <a>XPrv</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPrv :: XPrv -> Icarus depth XPrv

-- | Unsafe backdoor for constructing an <a>Icarus</a> key from a raw
--   <a>XPub</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPub :: XPub -> Icarus depth XPub
instance GHC.Enum.Bounded Cardano.Address.Style.Icarus.Role
instance GHC.Classes.Ord Cardano.Address.Style.Icarus.Role
instance GHC.Classes.Eq Cardano.Address.Style.Icarus.Role
instance GHC.Show.Show Cardano.Address.Style.Icarus.Role
instance GHC.Generics.Generic Cardano.Address.Style.Icarus.Role
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Generics.Generic (Cardano.Address.Style.Icarus.Icarus depth key)
instance GHC.Base.Functor (Cardano.Address.Style.Icarus.Icarus depth)
instance GHC.Show.Show Cardano.Address.Style.Icarus.ErrInspectAddress
instance GHC.Exception.Type.Exception Cardano.Address.Style.Icarus.ErrInspectAddress
instance Control.DeepSeq.NFData Cardano.Address.Style.Icarus.Role
instance GHC.Enum.Enum Cardano.Address.Style.Icarus.Role
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Icarus.Icarus
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Address.Style.Icarus.Icarus depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.Derivation.SoftDerivation Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.PaymentAddress Cardano.Address.Style.Icarus.Icarus
instance Cardano.Address.HasNetworkDiscriminant Cardano.Address.Style.Icarus.Icarus


module Data.Word7

-- | A <a>Word7</a> algebraic data-type. @since 2.0.0
data Word7
toWord7 :: Word8 -> Word7
toWord8 :: Word7 -> Word8
toWord7s :: Natural -> [Word7]
toNatural :: [Word7] -> Natural
putVariableLengthNat :: Natural -> Put
getVariableLengthNat :: Get Natural
instance GHC.Show.Show Data.Word7.Word7
instance GHC.Classes.Eq Data.Word7.Word7


module Cardano.Address.Style.Shelley

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = Shelley 'RootK XPrv
--   let accountPubKey  = Shelley 'AccountK XPub
--   let addressPubKey  = Shelley 'PaymentK XPub
--   </pre>
data Shelley (depth :: Depth) key

-- | Extract the raw <a>XPrv</a> or <a>XPub</a> wrapped by this type.
getKey :: Shelley depth key -> key

-- | Describe what the keys within an account are used for.
--   
--   <ul>
--   <li>UTxOExternal: used for public addresses sent to other parties for
--   receiving money.</li>
--   <li>UTxOInternal: generated by wallet software to send change back to
--   the wallet.</li>
--   <li>Stake: used for stake key(s) and delegation.</li>
--   <li>Multisig: used for keys used in multi-party transactions /
--   scripts.</li>
--   </ul>
data Role
UTxOExternal :: Role
UTxOInternal :: Role
Stake :: Role
Multisig :: Role

-- | Shelley offers several ways to identify ownership of entities on
--   chain.
--   
--   This data-family has two instances, depending on whether the key is
--   used for payment or for delegation.
data family Credential (purpose :: Depth)

-- | Generate a root key from a corresponding root <a>XPrv</a>
genMasterKeyFromXPrv :: XPrv -> Shelley  'RootK XPrv

-- | Generate a root key from a corresponding mnemonic.
genMasterKeyFromMnemonic :: SomeMnemonic -> ScrubbedBytes -> Shelley  'RootK XPrv

-- | Derives an account private key from the given root private key.
deriveAccountPrivateKey :: Shelley  'RootK XPrv -> Index  'Hardened  'AccountK -> Shelley  'AccountK XPrv

-- | Derives an address private key from the given account private key.
deriveAddressPrivateKey :: Shelley  'AccountK XPrv -> Role -> Index  'Soft  'PaymentK -> Shelley  'PaymentK XPrv

-- | Derive a delegation key for a corresponding <a>AccountK</a>. Note that
--   wallet software are by convention only using one delegation key per
--   account, and always the first account (with index 0').
--   
--   Deriving delegation keys for something else than the initial account
--   is not recommended and can lead to incompatibility with existing
--   wallet softwares (Daedalus, Yoroi, Adalite...).
deriveDelegationPrivateKey :: Shelley  'AccountK XPrv -> Shelley  'DelegationK XPrv

-- | Derives an address public key from the given account public key.
deriveAddressPublicKey :: Shelley  'AccountK XPub -> Role -> Index  'Soft  'PaymentK -> Shelley  'PaymentK XPub

-- | Derives a multisig private key from the given account private key.
deriveMultisigPrivateKey :: Shelley  'AccountK XPrv -> Index  'Soft  'PaymentK -> Shelley  'ScriptK XPrv

-- | Derives a multisig public key from the given account public key.
deriveMultisigPublicKey :: Shelley  'AccountK XPub -> Index  'Soft  'PaymentK -> Shelley  'ScriptK XPub

-- | Analyze an <a>Address</a> to know whether it's a Shelley address or
--   not.
--   
--   Throws <tt>AddrError</tt> if it's not a valid Shelley address, or a
--   ready-to-print string giving details about the <a>Address</a>.
inspectAddress :: (Alternative m, MonadThrow m) => Maybe XPub -> Address -> m Value

-- | Convert a payment credential (key or script) to a payment
--   <a>Address</a> valid for the given network discrimination.
paymentAddress :: NetworkDiscriminant Shelley -> Credential  'PaymentK -> Address

-- | Convert a payment credential (key or script) and a delegation
--   credential (key or script) to a delegation <a>Address</a> valid for
--   the given network discrimination. Funds sent to this address will be
--   delegated according to the delegation settings attached to the
--   delegation key.
delegationAddress :: NetworkDiscriminant Shelley -> Credential  'PaymentK -> Credential  'DelegationK -> Address

-- | Convert a payment credential (key or script) and pointer to delegation
--   certificate in blockchain to a pointer <a>Address</a> valid for the
--   given network discrimination.
pointerAddress :: NetworkDiscriminant Shelley -> Credential  'PaymentK -> ChainPointer -> Address

-- | Convert a delegation credential (key or script) to a stake Address
--   (aka reward account address) for the given network discrimination.
stakeAddress :: NetworkDiscriminant Shelley -> Credential  'DelegationK -> Either ErrInvalidStakeAddress Address

-- | Extend an existing payment <a>Address</a> to make it a delegation
--   address.
extendAddress :: Address -> Credential  'DelegationK -> Either ErrExtendAddress Address

-- | Captures error occuring when trying to extend an invalid address.
data ErrExtendAddress
ErrInvalidAddressStyle :: String -> ErrExtendAddress
ErrInvalidAddressType :: String -> ErrExtendAddress

-- | Possible errors from inspecting a Shelley address
data ErrInspectAddress
UnknownAddrType :: ErrInspectAddress

-- | Actual size
WrongInputSize :: Int -> ErrInspectAddress

-- | Human readable error of underlying operation
PtrRetrieveError :: String -> ErrInspectAddress

-- | Pretty-print an <a>ErrInspectAddress</a>
prettyErrInspectAddress :: ErrInspectAddress -> String

-- | Error reported from trying to create a network discriminant from
--   number
newtype MkNetworkDiscriminantError

-- | Wrong network tag.
ErrWrongNetworkTag :: Integer -> MkNetworkDiscriminantError

-- | Construct <a>NetworkDiscriminant</a> for Cardano <a>Shelley</a> from a
--   number. If the number is invalid, ie., not between 0 and 15, then
--   <a>MkNetworkDiscriminantError</a> is thrown.
mkNetworkDiscriminant :: Integer -> Either MkNetworkDiscriminantError (NetworkDiscriminant Shelley)

-- | Retrieve the network discriminant of a given <a>Address</a>. If the
--   <a>Address</a> is malformed or, not a shelley address, returns
--   Nothing.
inspectNetworkDiscriminant :: Address -> Maybe (NetworkDiscriminant Shelley)

-- | <tt>NetworkDicriminant</tt> for Cardano MainNet &amp; Shelley
shelleyMainnet :: NetworkDiscriminant Shelley

-- | <tt>NetworkDicriminant</tt> for Cardano Testnet &amp; Shelley
shelleyTestnet :: NetworkDiscriminant Shelley

-- | Unsafe backdoor for constructing an <a>Shelley</a> key from a raw
--   <a>XPrv</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPrv :: XPrv -> Shelley depth XPrv

-- | Unsafe backdoor for constructing an <a>Shelley</a> key from a raw
--   <a>XPub</a>. this is unsafe because it lets the caller choose the
--   actually derivation <tt>depth</tt>.
--   
--   This can be useful however when serializing / deserializing such a
--   type, or to speed up test code (and avoid having to do needless
--   derivations from a master key down to an address key for instance).
liftXPub :: XPub -> Shelley depth XPub
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.AddressType
instance GHC.Show.Show Cardano.Address.Style.Shelley.AddressType
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.CredentialType
instance GHC.Show.Show Cardano.Address.Style.Shelley.CredentialType
instance GHC.Show.Show Cardano.Address.Style.Shelley.MkNetworkDiscriminantError
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.MkNetworkDiscriminantError
instance GHC.Show.Show Cardano.Address.Style.Shelley.ErrExtendAddress
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.ErrInvalidStakeAddress
instance GHC.Show.Show Cardano.Address.Style.Shelley.ErrInvalidStakeAddress
instance GHC.Generics.Generic Cardano.Address.Style.Shelley.ErrInvalidStakeAddress
instance GHC.Show.Show Cardano.Address.Style.Shelley.ErrInspectAddress
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.ErrInspectAddress
instance GHC.Enum.Bounded Cardano.Address.Style.Shelley.Role
instance GHC.Classes.Ord Cardano.Address.Style.Shelley.Role
instance GHC.Classes.Eq Cardano.Address.Style.Shelley.Role
instance GHC.Show.Show Cardano.Address.Style.Shelley.Role
instance GHC.Generics.Generic Cardano.Address.Style.Shelley.Role
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Address.Style.Shelley.Shelley depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Address.Style.Shelley.Shelley depth key)
instance GHC.Generics.Generic (Cardano.Address.Style.Shelley.Shelley depth key)
instance GHC.Show.Show (Cardano.Address.Style.Shelley.Credential 'Cardano.Address.Derivation.PaymentK)
instance GHC.Show.Show (Cardano.Address.Style.Shelley.Credential 'Cardano.Address.Derivation.DelegationK)
instance GHC.Base.Functor (Cardano.Address.Style.Shelley.Shelley depth)
instance Formatting.Buildable.Buildable Cardano.Address.Style.Shelley.MkNetworkDiscriminantError
instance GHC.Exception.Type.Exception Cardano.Address.Style.Shelley.ErrInspectAddress
instance Control.DeepSeq.NFData Cardano.Address.Style.Shelley.Role
instance GHC.Enum.Enum Cardano.Address.Style.Shelley.Role
instance Cardano.Address.Derivation.HardDerivation Cardano.Address.Style.Shelley.Shelley
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Address.Style.Shelley.Shelley depth key)
instance Cardano.Address.Derivation.GenMasterKey Cardano.Address.Style.Shelley.Shelley
instance Cardano.Address.Derivation.SoftDerivation Cardano.Address.Style.Shelley.Shelley
instance Cardano.Address.HasNetworkDiscriminant Cardano.Address.Style.Shelley.Shelley
